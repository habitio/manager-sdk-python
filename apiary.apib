FORMAT: 1A
HOST: https://api.platform.qa.muzzley.com

# How to integrate devices with Habit Analytics

## Connecting people and machines

Habit Analytics' platform (muzzley) aims at efficiently and effectively connect, in real-time, people and machines, allowing end-users and software programs to
establish communication channels and exchange information or actionable requests. It's stated _software programs_ and not devices, because Habit doesn't 
restrict the ontology used within the established communication channels, although IoT devices are widely supported and the most common integration
within Habit.

In order to be able to act as an _intervenient_ in the Habit platform, 2 things are required:

- _intervenient_ credentials, generated by the Habit platform
- the hability to interact through one of the communication protocols:
  - [HTTP](https://tools.ietf.org/html/rfc7235)
  - [MQTT](http://mqtt.org/)

Once these requirements are established, the _intervenient_ will be able to (Figure 1):

1. interact with a RESTful API to setup, manage and access it's own and other _intervenients_ data.
2. use an MQTT infrastructure to establish real-time communication with other _intervenients_

||
|:------:|
|![Figure 1 - interacting with Habit](http://cdn.muzzley.com/documentation/muzzley_platform_01.png)|
|Figure 1 - interacting with Habit - [zoom in](http://cdn.muzzley.com/documentation/muzzley_platform_01.png)|

There are the following types of _intervenients_, each with a set of permissions and allowed types of interactions:

- _user_: represents the end-user of the platform
- _application_: represents the _software program_ that interacts with the platform on behalf of the _user_
- _device_: represents **things** that the user wishes to interact with and connects directly with the platform
- _manager_: represents the _software program_ that interacts with the platform on behalf of _devices_ hosted in and proxied by the manufacturer cloud

In this tutorial we will focus, mainly, on _managers_ and _devices_.

## Meaningful communication (Specification)

Having _meaningful communication_ between _intervenients_ means to empower interactions with the type of structured data that allows efficient and effective data analyses. 

In order to be able to achieve this level of analysis whithout restricting the structure of data used, the specification of ontology schemas is mandatory 
and each communication channel must relate to and uphold a given schema.

This allows data observers to process the metadata associated with the ontology schema, understand the communication between _intervenients_ and produce relevant 
additional knowledge and higher levels of data abstraction.

Each low-level communication channel is managed by an entity denoted _channel_. A _channel_ is composed of _components_ and/or _properties_ (Figure 2). 

||
|:------:|
|![Figure 2 - channel structure](http://cdn.muzzley.com/documentation/muzzley_platform_04.png)|
|Figure 2 - channel structure - [zoom in](http://cdn.muzzley.com/documentation/muzzley_platform_04.png)|

_Channels_ are entities that represent the communication channels opened between _intervenients_. They are unique and allow the setup, configuration and management
of low-level communication channels, regarding access permissions, message schema validation and message routing and broadcasting.

_Components_ are containers that will hold other _components_ and/or _properties_, with no special characterization regarding data, just the specification of 
usage categories. _Components_ are crucial to contextualize and organize _properties_ (like folders in a filesystem).

_Properties_ are the entities that represent data being sent over the communication channels, between _intervenients_. _Properties_ may represent actions or just storage 
records. _Properties_ are characterized by a data type, unit system, unit type, usage categories and permission set.

In order to characterize _channels_, _components_ and _properties_, tools to specify ontology schemas, denoted _specs_, are provided. 

_Specs_ are schema specifications for _channels_, _components_ and _properties_, There are 3 types of specs _channel specs_, _component specs_ and 
_property specs_ each one related to each level of the communication channel hierarchy (Figure 3).

||
|:------:|
|![Figure 3 - specs and channels](http://cdn.muzzley.com/documentation/muzzley_platform_05.png)|
|Figure 3 - specs and channels - [zoom in](http://cdn.muzzley.com/documentation/muzzley_platform_05.png)|

Each _spec_ schema may be associated with one or more templates, characterizing a given brand, model and manufacturer, denoted 
_channel template_ (Figure 4). 

||
|:------:|
|![Figure 4 - channel templates](http://cdn.muzzley.com/documentation/muzzley_platform_06.png)|
|Figure 4 - channel templates - [zoom in](http://cdn.muzzley.com/documentation/muzzley_platform_06.png)|

The _channel template_ entity is composed by the brand name, model, manufacturer, descriptive texts and images. Each _channel_ must be
associate to a _channel template_ (Figure 5). The _channel_ is created as an instance of a _channel template_.

||
|:------:|
|![Figure 5 - channels as template instances](http://cdn.muzzley.com/documentation/muzzley_platform_07.png)|
|Figure 5 - channels as template instances - [zoom in](http://cdn.muzzley.com/documentation/muzzley_platform_07.png)|

After _specs_ and _templates_ are in place, a _chanel_ may be generated based on a _channel template_. The generated _channel_ will have a hierarchy
mirrored from the underlying _spec_ hierarchy. Each _channel_ part may be configured and accessed via the respective topic:

- **/v3/channels/{id}** to access the _channel_ configuration
- **/v3/channels/{id}/components/{id or namespace}** to access the _component_ configuration
- **/v3/channels/{id}/components/{id or namespace}/property/{id or namespace}** to access the _property_ configuration or for engaging in interactions

For instance, given the examples in the above figures, one could send a message to another _intervenient_ by publishing to _/v3/channels/be5d4510-94a7-11e7-b1bf-c33cf9be2246/components/thermostat/properties/mode_

## Integrate devices

There are two ways to integrate devices with the Habit platform:

- _Cloud-to-cloud_, a connector between the manufacturer cloud and the Habit cloud, translating one ontology into the other (Figure 6)
- _Device-to-cloud_, a connector to embed in a device, that will speak directly with the Habit cloud (Figure 7)

### Cloud-to-cloud

The cloud-to-cloud integration is composed by the following steps:

1. Configuration
   1. Request Habit to setup your channel specification 
2. Runtime initialization
   1. OAuth 2.0 authorization via **/v3/auth/authorize**
   2. _Manager_ webhook callbacks registration via **/v3/managers/{id}**
   3. _Manager channel_ MQTT topic subscription via **/v3/managers/{id}/channels/#**
3. Implementation
   1. Manufacturer authentication redirection webhook, denoted **authorize** callback
   2. Manufacturer access token storage webhook, denoted **receive_token** callback
   3. User device listing webhook, denoted **devices_list** callback
   4. Add device to user's Habit account webhook, denoted **select_device** callback
   5. MQTT message listener and handler


||
|:------:|
|![Figure 6 - cloud-to-cloud](http://cdn.muzzley.com/documentation/muzzley_platform_02.png)|
|Figure 6 - cloud-to-cloud - [zoom in](http://cdn.muzzley.com/documentation/muzzley_platform_02.png)|

### Device-to-cloud

The device-to-cloud integration is composed by the following steps:

1. Configuration
   1. Request Habit to setup your channel specification 
2. Runtime initialization
   1. If credentials are inexistent or lost, request Habit your credentials via **/v3/utils/device-authenticate**
   2. OAuth 2.0 authorization via **/v3/auth/authorize**
   3. Create a channel for each device (in case your integrating a hub, you will need a _channel_ per _device_ connected to the hub).
   4. _Device channel_ MQTT topic subscription via **/v3/devices/{id}/channels/#**
   5. _Device grant_ MQTT topic subscription via **/v3/devices/{id}/grants/#**
   6. Listen to broadcast messages for local wifi discovery
3. Implementation
   1. MQTT message listener and handler


||
|:------:|
|![Figure 7 - device-to-cloud](http://cdn.muzzley.com/documentation/muzzley_platform_03.png)|
|Figure 7 - device-to-cloud - [zoom in](http://cdn.muzzley.com/documentation/muzzley_platform_03.png)|

## Terminology

- _**intervenient**_: every _software program_ that hold a set of credentials and is able to interact through one of the allowed protocols
- _**user**_: _intervenient_ that represents the end-user of the platform
- _**application**_: _intervenient_ that represents the _software program_ that interacts with the platform on behalf of the _user_
- _**device**_: _intervenient_ that represents **things** that the user wishes to interact with and connects directly with the platform
- _**manager**_: _intervenient_ that represents the _software program_ that interacts with the platform on behalf of _devices_ hosted in and proxied by the manufacturer cloud
- _**channel**_: representation on the communication channel between two or more _intervenients_, used to exchange messages matching the underlying ontology schema
- _**component**_: parts of the _intervenients channels_, used to organize sets of _properties_
- _**property**_: entities that represent data being sent over the communication channels
- _**channel spec**_: schema specification for a _channel_
- _**component spec**_: schema specification for a _component_
- _**property spec**_: schema specification for a _property_
- _**channel template**_: template for characterizing a communication channel for a brand / model / manufacturer

# Group Accessing the API

## Authentication with OAuth 2.0 [/v3/auth/authorize{?client\_id,client\_secret,response\_type,scope,redirect\_uri,state}]

In order to interact with the Habit API, clients must authenticate using the [OAuth 2.0 protocol](https://tools.ietf.org/html/rfc6749), in particular the 
[Client credentials flow](https://tools.ietf.org/html/rfc6749#page-9). This call must be made using the **/v3/auth/authorize** endpoint, passing pre-generated
credentials, called _client\_id_ and _client\_secret_.

Other parameters may / must also be provided, being:

- _response\_type_, indicating the flow type, in this case _**client\_credentials**_
- _scope_, indicating the requested permissions, in this case _**manager**_ or _**device**_
- _redirect\_uri_, in case the clients needs to be redirect to a hosted callback
- _state_, a value to be passed as part of the authorization result

The response will be populated with, at least, 4 main attributes:

- _access\_token_, the actual token to be used in subsequent calls
- _expires_, the validity of the returned tokens
- _refresh\_token_, for refreshing this information, before _expires_ is reached
- _endpoints_, an object containing the _HTTP_ and _MQTT_ base URLs assigned to the requesting client

All subsequent calls must be directed to the base URL provided in _endpoints.http_ and an _Authorization_ header must be added to every API call, in the form:

```
    Authorization: Bearer {access_token}
```

### Request parameters

| PARAMETER | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**client\_id**_ | uuid | the client unique identifier, provided by the Habit self-care |
| _**client\_secret**_ | string | automatically generated hash, provide by the Habit self-care |
| _**redirect\_uri**_ | uri | URI to be provided to the user-agent as part of a **303** or **307** HTTP response |
| _**response\_type**_ | string | the _OAuth 2.0_ flow to be used |
| _**scope**_ | string | a comma separated string of permissions to be associated with the token |
| _**state**_ | string | a general purpose string that will be forwarded and added to the flow final result |

### Response fields

| FIELD | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**access\_token**_ | string | the token to be used in subsequent calls to the API as part of an _HTTP Authorization_ header  |
| _**client\_id**_ | uuid | the client unique identifier |
| _**code**_ | string | an exchange code, for usage with _code_ flow requests |
| _**endpoints**_ | object | _HTTP_ and _MQTT_ base URLs assigned to the requesting client |
| _**expires**_ | timestamp | the expiration date for the provided tokens |
| _**grant\_type**_ | string | the type of grant flow used to generate the provided tokens |
| _**refresh\_token**_ | string | a token used with **/v3/auth/exchange** to retrieve fresh tokens, without the re-executing the entire flow |
| _**scope**_ | array | granted permissions associated with the provided tokens |
| _**state**_ | string | general purpose string forwarded by the client in the first flow call |

### Call using POST method [POST]

+ Request (application/json)

    + Body

            {
                    "client_id": "bef41164-90c6-11e7-a25d-97266664a105",
                    "client_secret": "CLIENT_SECRET",
                    "response_type": "client_credentials",
                    "scope" : "manager",
                    "state":"active"
            }

+ Response 200 (application/json)

        {
                "access_token":"pi34fshyb19niugymus2skd174nmp2z0j1nvmegaxz4ji0zfwjxolee74ydrv2x5s8zfly81hzh26v6295e0wxystsrb936l2xyr8w4t2grdxxo0pvz7l1lzz5298k5j",
                "client_id": "bef41164-90c6-11e7-a25d-97266664a105",
                "code":"2apu31cfkizrmneyt55hph5x2xadkp0rrqblvfhc7z47daalj29iw4bk28mpzg0r",
                "endpoints":{
                        "http":"https:\/\/api.platform.qa.muzzley.com",
                        "mqtt":"mqtts:\/\/api.platform.qa.muzzley.com:8883"
                },
                "expires":"2017-12-03T02:08:01.582+0000",
                "grant_type":"client_credentials",
                "refresh_token":"l8puku66syp5llktgrtrrxgw6vqc8hm109yfsf3wcm1t2dpkzoxs6na3na0zzc2q",
                "scope":[
                        "manager"
                ]
        }

### Call using GET method [GET]

+ Parameters
    + client\_id (required, string)
    + client\_secret (required, string)
    + response\_type (required, string)
    + scope (required, string)
    + redirect\_uri (optional, string)
    + state (optional, string)

+ Request (application/json)

+ Response 307 

    + Headers 
      
            Location: https://mydomain.com/drop_credentials?expires=2017-12-03T02:08:01.582+0000&refresh_token=l8puku66syp5llktgrtrrxgw6vqc8hm109yfsf3wcm1t2dpkzoxs6na3na0zzc2q&access_token=pi34fshyb19niugymus2skd174nmp2z0j1nvmegaxz4ji0zfwjxolee74ydrv2x5s8zfly81hzh26v6295e0wxystsrb936l2xyr8w4t2grdxxo0pvz7l1lzz5298k5j

## Renew authorization [/v3/auth/exchange{?client\_id,refresh\_token,grant\_type,redirect\_uri}]

Before the expiration timestamp returned in _expires_, the _intervenient_ should renew the access token by calling **/v3/auth/exchange** endpoint, passing
the _refresh\_token_ return by the call to **/v3/auth/authorize**. 

The return will be exactly the same as return by **/v3/auth/authorize**.

### Request parameters

| PARAMETER | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**client\_id**_ | uuid | the client unique identifier, provided by the Habit self-care |
| _**redirect\_uri**_ | uri | URI to be provided to the user-agent as part of a **303** or **307** HTTP response |
| _**refresh\_token**_ | string | the token provided as _refresh\_token_ in a previous call to **/v3/auth/authorize** |
| _**grant\_type**_ | string | the type of grant flow used to generate the provided tokens |

### Response fields

| FIELD | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**access\_token**_ | string | the token to be used in subsequent calls to the API as part of an _HTTP Authorization_ header  |
| _**client\_id**_ | uuid | the client unique identifier |
| _**code**_ | string | an exchange code, for usage with _code_ flow requests |
| _**endpoints**_ | object | _HTTP_ and _MQTT_ base URLs assigned to the requesting client |
| _**expires**_ | timestamp | the expiration date for the provided tokens |
| _**grant\_type**_ | string | the type of grant flow used to generate the provided tokens |
| _**refresh\_token**_ | string | a token used with **/v3/auth/exchange** to retrieve fresh tokens, without executing the entire flow |
| _**scope**_ | array | granted permissions associated with the provided tokens |

### Call using POST method [POST]

+ Request (application/json)

    + Body

            {
                    "client_id": "bef41164-90c6-11e7-a25d-97266664a105",
                    "refresh_token": "l8puku66syp5llktgrtrrxgw6vqc8hm109yfsf3wcm1t2dpkzoxs6na3na0zzc2q",
                    "grant_type": "client_credentials"
            }

+ Response 200 (application/json)

        {
                "access_token": "7enfl95a36qa72go4cdgd7usvln0riijh19a1bmbtjdkkoltn5l5fcfth397snao5ut79gageyv41zfoiourpkt3a1b7p6bzr9jwwiqi26emu33qdabq1vufw627oetv",
                "client_id": "bef41164-90c6-11e7-a25d-97266664a105",
                "code": "cl98bv8kkvcu4ele2pnmsau2befvnuamni3eq6wu6oi4o410bwhn9sfalk9vds9q",
                "endpoints":{
                        "http":"https:\/\/api.platform.qa.muzzley.com",
                        "mqtt":"mqtts:\/\/api.platform.qa.muzzley.com:8883"
                },
                "expires":"2017-12-03T04:08:01.582+0000",
                "grant_type":"client_credentials",
                "refresh_token":"39cyl6fjcotgvkbc2cf3583r8xf2ezai37wknrijplenjb9ngt492ojww4zhffut",
                "scope":[
                        "manager"
                ]
        }

### Call using GET method [GET]

+ Parameters
    + client\_id (required, string)
    + refresh\_token (required, string)
    + grant\_type (required, string)
    + redirect\_uri (optional, string)
    

+ Request (application/json)

+ Response 307 

    + Headers 
      
            Location: https://mydomain.com/drop_credentials?expires=2017-12-03T04:08:01.582+0000&refresh_token=39cyl6fjcotgvkbc2cf3583r8xf2ezai37wknrijplenjb9ngt492ojww4zhffut&access_token=7enfl95a36qa72go4cdgd7usvln0riijh19a1bmbtjdkkoltn5l5fcfth397snao5ut79gageyv41zfoiourpkt3a1b7p6bzr9jwwiqi26emu33qdabq1vufw627oetv


## Group Accessing channels with MQTT

For reading about the MQTT protocol, please, refer to the [official documentation](http://mqtt.org/)

Each _intervenient_ should listen for MQTT messages by subscribing it's channels topic. For instance:

if it's a manager: /v3/managers/{id}/channels/#

if it's a device: /v3/devices/{id}/channels/#

Each _intervenient_ should send MQTT messages by publishing to the _channel_ topic, **/v3/channels/{id}/components/{namespace}/properties/{namespace}/value**

Each _intervenient_ must provide is unique identifier (_client\_id_) as MQTT user and the previously retrieved _access\_token_ as password.

## Message structure

Each message received or sent to the MQTT topic associated with a given _property_ must state the underlying _performative_. The _performative_ contextualizes the 
receiving _intervenient_ on what to proceed. 

Allowed _performatives_ are:

- **w**, that asks the receiving _intervenient_ to change the _property_ value
- **r**, that ask the receiving _intervenient_ for the _property_ value
- **iw**, that informs the receiving _intervenient_ of the _property_ value, as a result of a **w** _performative_ message
- **ir**, that informs the receiving _intervenient_ of the _property_ value, as a result of a **r** _performative_ message

Every time the manager receives a request to read or write and it is not possible to execute it due to a problem with the manufacturers communication, a "iw" should be send back, to the property "access", with the following data: "unreachable".


### Message parameters

| PARAMETER | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**io**_ | string | The _performative_, stating what to do with this message |
| _**value**_ | any | The _property_ value, structured as specified in the underlying _property spec_ |
| _**sender**_ | uuid | The requesting _intervenient_ unique identifier (read-only, no need to instantiate and if instantiate, overwritten by the platform) Same as the X-Client-Id from the webhook calls |
| _**on_behalf_of**_ | uuid | The _intervenient_ unique identifier on behalf of the requesting _intervenient_ is sending this message. Typically for _access tokens_ that were acquired through the **password** flow, that usually apply to the _application_ -> _user_ relation (read-only, no need to instantiate and if instantiate, overwritten by the platform) Same as the X-Owner-Id from the webhook calls |
| _**timestamp**_ | timestamp | Timestamp for the moment the message was sent (read-only, no need to instantiate and if instantiate, overwritten by the platform) |

### Example

```json
{
    "io" : "w",
    "sender" : "c9a78b2c-94a9-11e7-a76d-4b1c78a6ed17",
    "on_behalf_of" : "18f52e1a-9ebd-11e7-8613-e70c15c3f16f",
    "timestamp" : "2017-08-28T00:34::40.000+0000"
    "data" : {
        "location" : [ -34.9823479, 12.445989 ]
        "velocity" : 38.5587
    }
}
```

### MQTT clients

A list of MQTT clients support several developing languages:

- [Eclipse Paho](http://www.eclipse.org/paho/)
- [Mosquitto](https://mosquitto.org/)





# Group Cloud-to-Cloud Implementation

In the following sections, **Python** coding examples will be provided. In order for them to run, the following dependencies should be installed:

1. [Python 3+](https://www.python.org/downloads/release/python-360/)
3. [Flask](http://flask.pocoo.org/)

## Webhook registration [/v3/managers/{id}]

At runtime, the _manager_ SHOULD update it's own webhook callback registers, in order to keep updated the URL's where it can be found
by other _intervenients_ interested in interacting.

This may be accomplished via **/v3/managers/{id}**, the _manager_ document resource. Each callback type is stored as an attribute of
this document.

The return message for this request will provide a _confirmation hash_ field. This hash will be passed on with 
each webhook callback invocation, as a part of the HTTP **Authorization** header. The _manager_ should validate the received hash against the one it as access on the platform by requesting */v3/managers/{id}*, in order to confirm that the request is being sent by the Habit platform.

### Request parameters

| PARAMETER | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**authorize**_ | uri | URL for the webhook callback providing info for the manufacturer cloud authorization flow. This field is _mandatory_. |
| _**receive\_token**_ | uri | URL for the webhook callback that will store the manufacturer cloud authorization info. This field is _mandatory_. |
| _**devices\_list**_ | uri |  URL for the webhook callback providing the user's list of devices registered with the manufacturer cloud. This field is _mandatory_. |
| _**select\_device**_ | uri |  URL for the webhook callback that will create a _channel_ between the request _intervenient_ and this _manager_. The data exchanges in this _channel_ usually regards a device registered with the manufacturer cloud This field is _mandatory_. |

### Response fields

| FIELD | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**n\_updated**_ | uri | Number of updated documents. |
| _**confirmation_hash**_ | uri | Hash to be kept and tested against the hash passed on in each subsequent call to the webhook callbacks, in the Authorization header. |

### Register webhooks [PATCH]

+ Parameters
    + id (required, string)


+ Request (application/json)

    + Headers

            Authorization: Bearer {token}

    + Body

            {
                     "authorize":"https://api.something.something/authorize",
                     "receive_token":"https://api.something.something/receive-token",
                     "devices_list":"https://api.something.something/device-list",
                     "select_device":"https://api.something.something/select-device"
            }

+ Response 200 (application/json)

        {
                "n_updated":1,
                "confirmation_hash": "asdoifuaoiweufnioqwue9023ufionwdufuwe9fwajdoinfasoidfnoji"
                "href":"/v3/managers/{id}",
        }
        

## Authorize webhook [/v3/channel-templates/{id}/authorize?policy=one]

The **authorize** webhook callback (GET request) must provide information on how to authenticate / authorize against the manufacturer cloud, The platform only 
supports authentication / authorization flows that are HTTP based, for the time being. 

The callback must provide a list of HTTP requests that, when invoked sequentially, will provide with the necessary information to access the 
manufacturer cloud. 

Since the actual manufacturer cloud account may belong and be created by third-party _intervenients_ (usually, _applications_), the platform will 
take care of store and managing some parameters, like redirect_uri. Therefore, each URL provided in the set may contain placeholders to be filled in by 
the platform. The pre-defined supported placeholders are:

| PLACEHOLDER | DESCRIPTION |
|:------|:-------|
| _**redirect\_uri**_ |  The final redirect URL that will receive the authentication / authorization info |

There are also non pre-defined placeholders, the ones that allow to access the data returned by a URL defined in the set. In each defined URL, placeholders
representing the data returned by the **immediate previous URL call** may be used by referring to the returned field name.

The returned message should be a well formatted JSON with the following structure:

| FIELD | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**location**_ | array of objects | Array of URL call definitions to invoqued sequentially, when authenticating / authorizing against the manufacturer cloud |
| _**location.[].method**_ |string |  The HTTP method to be used |
| _**location.[].url**_ | uri |  The actual URL to be called |
| _**location.[].headers**_ | object | JSON object representing the HTTP headers to be included in the call. The field key will be matched to the header name and the field value with the header value |

For instance,

```json
{
    "location" : [
        {
            "method" : "get",
            "url" : "http://cloud.manufacturer.com/login?client_id={client_id}&client_secret={client_secret}&redirect_uri={redirect_uri}"
        },
        {
            "method" : "post",
            "url" : "http://cloud.manufacturer.com/authorize?redirect_uri={redirect_uri}",
            "headers" : {
                "Authorization" : "code {code}"
            }
        }
    ]
}
```

In the above example, a response field named _code_ is returned by the first call and used as a placeholder in the second call.

Each request always includes the following extra HTTP headers:

| HEADER | DESCRIPTION |
|:------|:-------|
| _**X-Client-Id**_ | The unique identifier for the requesting _intervenient_ (e.g. the _application_ being used)|
| _**X-Owner-Id**_ | The unique identifier for the _intervenient_ the requesting _intervenient_ is interaction on behalf of (e.g., _application_ interacting on behalf of the _user_)|
| _**X-Channeltemplate-Id**_ |  The unique identifier for the _channel template_ to be used |

If the chosen method is a POST call, all the URI parameters are converted to a JSON format and sent on the POST body of the request.

For the setup on manufaturer side, the redirect that should be provided is the following:
**https://{habit's platform host}/v3/third-party/credentials/inbox**

### Coding example

```python

from flask include Flask, request, Response

app = Flask(__name__)

@app.route('/1.0/authorize')
def authorize() :
    response = {
        "location" : [
            {
                "method" : "get",
                "url" : "http://cloud.manufacturer.com/login?client_id={client_id}&client_secret={client_secret}&redirect_uri={redirect_uri}"
            },
            {
                "method" : "post",
                "url" : "http://cloud.manufacturer.com/authorize?redirect_uri={redirect_uri}",
                "headers" : {
                    "Authorization" : "code {code}"
                }
            }
        ]
    }

    return Response(
        response=json.dumps(response),
        status=200,
        mimetype='application/json'
    )
```

### Test the authorize callback [GET]

+ Parameters
    + id (required, string)


+ Request (application/json)

    + Headers

            Authorization: Bearer {token}

+ Response 307 (application/json)

    + Headers
            
            Location: /some/final/redirect/url


## Receive token webhook [/v3/managers/{id}/receive-token]

The **receive_token** webhook callback (POST request) may be used to store the received manufacturer cloud authentication / authorization info. The structure
of the data is not defined and is as returned by the manufacturer cloud.
The same Habit user can pair more than one manufacturer account. This means that latter the same the received credentials should be stored by channel created and not only by user.

Each request always includes the following extra HTTP headers:

| HEADER | DESCRIPTION |
|:------|:-------|
| _**X-Client-Id**_ | The unique identifier for the requesting _intervenient_ (e.g. the _application_ being used)|
| _**X-Owner-Id**_ | The unique identifier for the _intervenient_ the requesting _intervenient_ is interaction on behalf of (e.g., _application_ interacting on behalf of the _user_)|
| _**X-Channeltemplate-Id**_ |  The unique identifier for the _channel template_ to be used |

### Coding example

```python

from flask include Flask, request, Response

app = Flask(__name__)

@app.route('/1.0/credentials')
def authorize() :
    store_on_db(request)
    
    return Response(
        status=200
    )
```

### Test Receive token webhook [POST]

+ Parameters
    + id (required, string)

+ Request (application/json)

    + Headers
    
            X-Client-Id: {client_id}
            X-Owner-Id: {owner_id}
        
    + Body
    
            {
                "access_token": "",
                "refresh_token": "",
                "token_type": ""
            }
            

+ Response 200 (application/json)

## List devices webhook [/v3/channel-templates/{id}/list-devices]

The **list_devices** webhook callback (POST request) must provide the list of devices that the requesting _intervenient_ has access to in the manufacturer cloud.

The returned message should be a well formatted JSON array, where each item is an object with the following structure:

| FIELD | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**content**_ | string | Device name or label |
| _**id**_ | string | Device identifier as returned by the manufacturer cloud |
| _**photoUrl**_ | uri | Device image |


For instance,

```json
[
    {
        "content" : "kitchen fridge",
        "id" : "9323u2450nwetu",
        "photoUrl" : "https://cdn.muzzley.com/device_img.png"
    },
    {
        "content" : "microwave",
        "id" : "qiwjfoiasqp34i",
        "photoUrl" : "https://cdn.muzzley.com/device_img.png"
    }
]
```

Each request always includes the following HTTP headers:

| HEADER | DESCRIPTION |
|:------|:-------|
| _**X-Client-Id**_ | The unique identifier for the requesting _intervenient_ (e.g. the _application_ being used)|
| _**X-Owner-Id**_ | The unique identifier for the _intervenient_ the requesting _intervenient_ is interaction on behalf of (e.g., _application_ interacting on behalf of the _user_)|
| _**X-Channeltemplate-Id**_ |  The unique identifier for the _channel template_ to be used |


### Coding example

```python

from flask include Flask, request, Response

app = Flask(__name__)

@app.route('/1.0/list-devices')
def list_devices() :
    message = request.get_json()
    devices = query_manufacturer(message)
    response = []
    
    for item in devices:
        response.append({
            content: item['description'], 
            id : item['uuid'],
            photoUrl : item['photo']
        })

    return Response(
        response=json.dumps(response),
        status=200,
        mimetype='application/json'
    )
```

### Test the devices_list callback [GET]

+ Parameters
    + id (required, string)

+ Request (application/json)

    + Headers

            Authorization: Bearer {token}
            X-Client-Id: {client_id}
            X-Owner-Id: {owner_id}
            X-Channeltemplate-Id: {channeltemplate_id}

+ Response 200 (application/json)
    
        [{
            "content" : "kitchen fridge",
            "id" : "9323u2450nwetu",
            "photoUrl" : "https://cdn.muzzley.com/device_img.png"
        },
        {
            "content" : "microwave",
            "id" : "qiwjfoiasqp34i",
            "photoUrl" : "https://cdn.muzzley.com/device_img.png"
        }]
  



## Select device webhook [/v3/channel-templates/{id}/select-device]

The **select_device** webhook callback (POST request) must create and instantiate all necessary resources needed to open a communication channel
between the requesting _intervenient_ and the _manager_, to interact over the selected devices.

The steps needed to accomplish this are:
1. Check if a _channel_ for a specific device already exists in your local database and check if it still exists on Habit system, if not create a _channel_ via **/v3/managers/self/channels**
To check in Habit system just make a GET to **/v3/channels/{id}** and it will return the channel object if still exists.
2. Grant the requesting _intervenient_ access to the created _channel_, via **/v3/channels/{channel_id}/grant-access**.
3. If the requesting _intervenient_ is interacting on behalf of a third _intervenient_, grant access also

To create a _channel_ the request body is a well formed JSON object with the following structure:

| FIELD | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**name**_ | string | Channel name |
| _**channeltemplate_id**_ | uuid | the corresponding _channel template_ uuid |

It will respond with the created channel_id.

After creating and giving access to all the selected devices, an array of objects should be returned in the response, with the following format:
[{'id': 'asdasd-asdasd-asdasd-asdasd'}] where the id is the created channel id.


### Coding example

```python

from flask include Flask, request, Response

app = Flask(__name__)

@app.route('/1.0/select-device')
def select_device() :
    message = request.get_json()
    channels = []
    
    for device in message['channels'] :

       if (!channel_already_exists(device)) :
                response = request.post('https://api.platform.qa.muzzley.com/v3/managers/self/channels', headers={'Content-Type': 'application/json'}, data=json.dumps({ 'name' : name, 'channeltemplate_id': request['headers']['X-Channeltemplate-Id'] }))
                channel_id = get_channel_id(response)
       else :
                channel_id = get_already_existing_channel_id(device)
       
       request.post('https://api.platform.qa.muzzley.com/v3/channels/' + channel_id + '/grant-access', headers={'Content-Type': 'application/json'}, data=json.dumps({ 'client_id' : request['headers']['X-Client-Id'], 'role' : 'application' }))
       request.post('https://api.platform.qa.muzzley.com/v3/channels/' + channel_id + '/grant-access', headers={'Content-Type': 'application/json'}, data=json.dumps({ 'client_id' : request['headers']['X-Owner-Id'], 'requesting_client_id' : request['headers']['X-Client-Id'], 'role' : 'user' }))
       
       channels.append({'id' : channel_id})

    return Response(
        response=json.dumps(channels),
        status=200,
        mimetype='application/json'
    )
```

### Test the select_device callback [POST]

+ Parameters
    + id (required, string)

+ Request (application/json)

    + Headers

            Authorization: Bearer {token}
    
    + Body 
        

+ Response 200 (application/json)

    + Body
    
                {  
                        "channeltemplate_id":"4abe37f6-c4a7-11e7-95a0-2b06c5c5f25a",
                        "profile":"4abe37f6-c4a7-11e7-95a0-2b06c5c5f25a",
                        "channels":[  
                                {  
                                        "id":"a453e764-94a2-11e7-8602-9bff7c5fecc8",
                                        "content":"kitchen fridge",
                                        "photoUrl" : "https://cdn.muzzley.com/device_img.png"
                                }, {  
                                        "id":"ac386892-94a2-11e7-aaf7-0b9dff403334",
                                        "content":"room fridge",
                                        "photoUrl" : "https://cdn.muzzley.com/device_img.png"
                                }
                        ]
                }

## MQTT message listener and handler [/v3/managers/{id}/channels/#]

Each _manager_ should listen for MQTT messages by subscribing the topic **/v3/managers/{id}/channels/#** and publish messages to the _channel_ topic, **/v3/channels/{id}/components/{namespace}/properties/{namespace}/value**, according to the previous [Accessing channels with MQTT](https://muzzleyintegrations.docs.apiary.io/#reference/accessing-channels-with-mqtt) section

### . [GET]


## Sample Project [/v3]

A python project that can be used as an example of how to make an integration with Muzzley: https://github.com/muzzley/manager-sdk-python

### . [GET]


# Group Device-to-Cloud Implementation

## Create new Device [/v3/inbox]

At runtime, the manager SHOULD request creation of a new _device_.

This may be accomplished via **/v3/utils/device-authenticate/inbox**, and passing information about the device and it's _channel_template_ secret.

The return message for this request will provide a _device_id_ which is a unique identifier in Habit platform and a _secret_ value. These will be used in the following step <a href="#reference/d2c:-implementation/request-credentials">Request Credentials</a>

### Test create new device [POST]

+ Request (application/json)

    + Headers

            Authorization: Bearer {token}
            
    + Body
    
            {
                "namespace" : "{namespace}",   
                "name": "{device name}",
                "serial": "{device serial}",
                "channeltemplate_id": "{channel-template id}",
                "secret":  "{channel-template secret}"
            }

+ Response 201 (application/json)

    + Body
    
            {
                "device_id": "b110234b-a801-434e-b520-9fe5f5d0404d",
                "secret": "ofQdR9PcwAHfk42p"
            }
 

## Request a new Channel  [/v3/devices/self/channels]

After successfully getting a _device_id_ and a valid [_access_token_]() and a new Channel for must be requested.

This call must be made using the **/v3/devices/self/channels** endpoint, passing previous received credentials.

The response will be populated with the created _channel_id_, with the following format {'id': 'b15ab84e-467c-45c2-af18-abfe8fb23e42'} where **id** is the created channel

### Test new channel [POST]

+ Request (application/json)

    + Headers
    
            Authorization: 'Bearer pi34fshyb19niugym672skd174nmp2z0j1nvmegaxz4ji0zfwjxolee74ydrv2x5s8zfly81hzh26v6295e0wxystsrb936l2xyr8w4t2grdxxo0pvz7l1lzz5298k5j'

    + Body
    
            {
                "name": "My device channel",
                "channeltemplate_id": "{channel-template}"
            }
    
+ Response 201 (application/json)

    + Body
    
            {
                "id": "b15ab84e-467c-45c2-af18-abfe8fb23e42"
            }
            

## MQTT message listener and handler [/v3/devices/{device_id}/]

In order to pair new devices or receive messages for the previously created channel, is mandatory to subscribe to the following mqtt topics:

- **Pairing process:**
By subscribing to the it's _grants_ topic (**/v3/devices/{device_id}/grants/#**), the device will be able to receive pairing requests for any of it's previously registered channels.


- **Read/Write messages:**
By subscribing to the it's _channels_ topic (**/v3/devices/{device_id}/channels/#**), the device will be able to receive read/write requests for any of it's components and properties. 


### . [GET]

## List devices [/broadcast]

When receiving a broadcast message with the following format  
`[CHANNEL_TEMPLATE_ID]##[USER_ID]##[APPLICATION_ID]`
Device manager should be able to recognize if the `CHANNEL_TEMPLATE_ID` requested match with their own. 
In this case it must reply with a message per `CHANNEL_TEMPLATE_ID` 

```json
{
    "device_id" : "{device_id}",
    "content": "{Device name}",
    "id": "{channel_id}",
    "channel_template_id": "{channel_template_id}",
    "photoUrl": "{url for photo}"
}
```

### Test list device[GET]

+ Request (application/json)

    + Body
            
            "ecc0718e-7a8b-4393-a147-f065ded81333##7d34ac99-b77f-4e09-be7e-0b7dc9bce6f7##a40d26a5-3036-4f1c-a43b-ee5ba41f38a9"
    
+ Response 200 (application/json)

    + Body
    
            {
                "device_id" : "b110234b-a801-434e-b520-9fe5f5d0404d",
                "content": "My device",
                "id": "b15ab84e-467c-45c2-af18-abfe8fb23e42",
                "channel_template_id": "{channel_template_id}",
                "photoUrl": "http://photo.example.com/test.png"
            }

 
## Select device [/v3/channels/{channel_id}/grant-access]

During pairing process, the _device_ will receive 2 different MQTT messages on **/v3/devices/{id}/grants** topic. 
One coming from an _application_ and other from an _user_, each identified in the _role_ field.

For messages with a _application_ role, the _device_ should:

- Validate the **client_id** value match with the APPLICATION_ID value received from the previous broadcast
- Request access to the created _channel_, via **/v3/channels/{channel_id}/grant-access** for the current _intervenient_ 

To request access, the request body is a well formed JSON object with the following structure:

| FIELD | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**client_id**_ | string | {application_id} |
| _**id**_ | string | {channel_id} |
| _**role**_ | string | 'application' |

- After a succesful request, device manager should send a confirmation mqtt message to the _intervenient_  topic with _performative_ **iw** and the same data received

#### MQTT _application_ request

```json
{
    "io" : "w",
    "data": {
            "client_id": "{application_id}",
            "id": "{channel_id}",
            "role": "application"
    }
}
```

#### MQTT _application_ response

```json
{
    "io" : "iw",
    "data": {
            "client_id": "{application_id}",
            "id": "{channel_id}",
            "role": "application"
    }
}
```

For messages with a _user_ role, the _device_ should:

- Validate the _client_id_ value match with the USER_ID value received from the previous broadcast
- Request access to the created _channel_, via **/v3/channels/{channel_id}/grant-access** for the current _intervenient_ 

To request access, the request body is a well formed JSON object with the following structure:

| FIELD | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**client_id**_ | string | {user_id} |
| _**requesting_client_id**_ | string | {application_id} |
| _**id**_ | string | {channel_id} |
| _**role**_ | string | 'user' |

- After a successful request, the _device_ should send a confirmation mqtt message to the _intervenient_  topic with _performative_ **iw** and the same data received

#### MQTT _user_ request

```json
{
    "io" : "w",
    "data": {
            "client_id": "{user_id}",
            "requesting_client_id": "{application_id}"
            "id": "{channel_id}",
            "role": "user"
    }
}
```

#### MQTT _user_ response

```json
{
    "io" : "iw",
    "data": {
            "client_id": "{user_id}",
            "requesting_client_id": "{application_id}"
            "id": "{channel_id}",
            "role": "user"
    }
}
```

### . [GET]


## MQTT message listener and handler [/v3/devices/{id}/channels/#]


With the previous subscription _channels_ topic subscription, device will receive requests to read or write it's properties.

### . [GET]