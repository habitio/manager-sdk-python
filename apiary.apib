FORMAT: 1A
HOST: https://api.platform.qa.muzzley.com

# How to integrate applications with Muzzley

## Connecting people and machines

Muzzley platform aims at efficiently and effectively connect, in real-time, people and machines, allowing end-users and software programs to
establish communication channels and exchange information or actionable requests. It's stated _software programs_ and not devices, because Muzzley doesn't 
restrict the ontology used within the established communication channels, although IoT devices are widely supported and the most common integration
within Muzzley.

In order to be able to act as an _intervenient_ in the Muzzley platform, 2 things are required:

- _intervenient_ credentials, generated by the Muzzley platform
- the hability to interact through one of the communication protocols:
  - [HTTP](https://tools.ietf.org/html/rfc7235)
  - [MQTT](http://mqtt.org/)

Once these requirements are established, the _intervenient_ will be able to (Figure 1):

1. interact with a RESTful API to setup, manage and access it's own and other _intervenients_ data.
2. use an MQTT infrastructure to establish real-time communication with other _intervenients_

||
|:------:|
|![Figure 1 - interacting with Muzzley](http://cdn.muzzley.com/documentation/muzzley_platform_01.png)|
|Figure 1 - interacting with Muzzley - [zoom in](http://cdn.muzzley.com/documentation/muzzley_platform_01.png)|

There are the following types of _intervenients_, each with a set of permissions and allowed types of interactions:

- _user_: represents the end-user of the platform
- _application_: represents the _software program_ that interacts with the platform on behalf of the _user_
- _device_: represents **things** that the user wishes to interact with and connects directly with the platform
- _manager_: represents the _software program_ that interacts with the platform on behalf of _devices_ hosted in and proxied by the manufacturer cloud

In this tutorial we will focus, mainly, on _application_.

## Meaningful communication (Specification)

Having _meaningful communication_ between _intervenients_ means to empower interactions with the type of structured data that allows efficient and effective data analyses. 

In order to be able to achieve this level of analysis whithout restricting the structure of data used, the specification of ontology schemas is mandatory 
and each communication channel must relate to and uphold a given schema.

This allows data observers to process the metadata associated with the ontology schema, understand the communication between _intervenients_ and produce relevant 
additional knowledge and higher levels of data abstraction.

Each low-level communication channel is managed by an entity denoted _channel_. A _channel_ is composed of _components_ and/or _properties_ (Figure 2). 

||
|:------:|
|![Figure 2 - channel structure](http://cdn.muzzley.com/documentation/muzzley_platform_04.png)|
|Figure 2 - channel structure - [zoom in](http://cdn.muzzley.com/documentation/muzzley_platform_04.png)|

_Channels_ are entities that represent the communication channels opened between _intervenients_. They are unique and allow the setup, configuration and management
of low-level communication channels, regarding access permissions, message schema validation and message routing and broadcasting.

_Components_ are containers that will hold other _components_ and/or _properties_, with no special characterization regarding data, just the specification of 
usage categories. _Components_ are crucial to contextualize and organize _properties_ (like folders in a filesystem).

_Properties_ are the entities that represent data being sent over the communication channels, between _intervenients_. _Properties_ may represent actions or just storage 
records. _Properties_ are characterized by a data type, unit system, unit type, usage categories and permission set.

In order to characterize _channels_, _components_ and _properties_, tools to specify ontology schemas, denoted _specs_, are provided. 

_Specs_ are schema specifications for _channels_, _components_ and _properties_, There are 3 types of specs _channel specs_, _component specs_ and 
_property specs_ each one related to each level of the communication channel hierarchy (Figure 3).

||
|:------:|
|![Figure 3 - specs and channels](http://cdn.muzzley.com/documentation/muzzley_platform_05.png)|
|Figure 3 - specs and channels - [zoom in](http://cdn.muzzley.com/documentation/muzzley_platform_05.png)|

Each _spec_ schema may be associated with one or more templates, characterizing a given brand, model and manufacturer, denoted 
_channel template_ (Figure 4). 

||
|:------:|
|![Figure 4 - channel templates](http://cdn.muzzley.com/documentation/muzzley_platform_06.png)|
|Figure 4 - channel templates - [zoom in](http://cdn.muzzley.com/documentation/muzzley_platform_06.png)|

The _channel template_ entity is composed by the brand name, model, manufacturer, descriptive texts and images. Each _channel_ must be
associate to a _channel template_ (Figure 5). The _channel_ is created as an instance of a _channel template_.

||
|:------:|
|![Figure 5 - channels as template instances](http://cdn.muzzley.com/documentation/muzzley_platform_07.png)|
|Figure 5 - channels as template instances - [zoom in](http://cdn.muzzley.com/documentation/muzzley_platform_07.png)|

After _specs_ and _templates_ are in place, a _chanel_ may be generated based on a _channel template_. The generated _channel_ will have a hierarchy
mirrored from the underlying _spec_ hierarchy. Each _channel_ part may be configured and accessed via the respective topic:

- **/v3/channels/{channel_id}** to access the _channel_ configuration
- **/v3/channels/{channel_id}/components/{id or namespace}** to access the _component_ configuration
- **/v3/channels/{channel_id}/components/{id or namespace}/property/{id or namespace}** to access the _property_ configuration or for engaging in interactions

For instance, given the examples in the above figures, one could send a message to another _intervenient_ by publishing to _/v3/channels/be5d4510-94a7-11e7-b1bf-c33cf9be2246/components/thermostat/properties/mode_

## Terminology

- _**intervenient**_: every _software program_ that hold a set of credentials and is able to interact through one of the allowed protocols
- _**user**_: _intervenient_ that represents the end-user of the platform
- _**application**_: _intervenient_ that represents the _software program_ that interacts with the platform on behalf of the _user_
- _**device**_: _intervenient_ that represents **things** that the user wishes to interact with and connects directly with the platform
- _**manager**_: _intervenient_ that represents the _software program_ that interacts with the platform on behalf of _devices_ hosted in and proxied by the manufacturer cloud
- _**channel**_: representation on the communication channel between two or more _intervenients_, used to exchange messages matching the underlying ontology schema
- _**component**_: parts of the _intervenients channels_, used to organize sets of _properties_
- _**property**_: entities that represent data being sent over the communication channels
- _**channel spec**_: schema specification for a _channel_
- _**component spec**_: schema specification for a _component_
- _**property spec**_: schema specification for a _property_
- _**channel template**_: template for characterizing a communication channel for a brand / model / manufacturer

# Group Accessing the API

## Authentication with OAuth 2.0 [/v3/auth/authorize{?client\_id,client\_secret,response\_type,scope,redirect\_uri,state}]

In order to interact with the Muzzley API, clients must authenticate using the [OAuth 2.0 protocol](https://tools.ietf.org/html/rfc6749), in particular the 
[Client credentials flow](https://tools.ietf.org/html/rfc6749#page-9). This call must be made using the **/v3/auth/authorize** endpoint, passing pre-generated
credentials, called _client\_id_ and _client\_secret_.

Other parameters may / must also be provided, being:

- _response\_type_, indicating the flow type, in this case _**client\_credentials**_
- _scope_, indicating the requested permissions, in this case _**application**_
- _redirect\_uri_, in case the clients needs to be redirect to a hosted callback
- _state_, a value to be passed as part of the authorization result

The response will be populated with, at least, 4 main attributes:

- _access\_token_, the actual token to be used in subsequent calls
- _expires_, the validity of the returned tokens
- _refresh\_token_, for refreshing this information, before _expires_ is reached
- _endpoints_, an object containing the _HTTP_ and _MQTT_ base URLs assigned to the requesting client

All subsequent calls must be directed to the base URL provided in _endpoints.http_ and an _Authorization_ header must be added to every API call, in the form:

```
    Authorization: Bearer {access_token}
```

### Request parameters

| PARAMETER | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**client\_id**_ | uuid | the client unique identifier, provided by the Muzzley self-care |
| _**client\_secret**_ | string | automatically generated hash, provide by the Muzzley self-care |
| _**redirect\_uri**_ | uri | URI to be provided to the user-agent as part of a **303** or **307** HTTP response |
| _**response\_type**_ | string | the _OAuth 2.0_ flow to be used |
| _**scope**_ | string | a comma separated string of permissions to be associated with the token |
| _**state**_ | string | a general purpose string that will be forwarded and added to the flow final result |

### Response fields

| FIELD | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**access\_token**_ | string | the token to be used in subsequent calls to the API as part of an _HTTP Authorization_ header  |
| _**client\_id**_ | uuid | the client unique identifier |
| _**code**_ | string | an exchange code, for usage with _code_ flow requests |
| _**endpoints**_ | object | _HTTP_ and _MQTT_ base URLs assigned to the requesting client |
| _**expires**_ | timestamp | the expiration date for the provided tokens |
| _**grant\_type**_ | string | the type of grant flow used to generate the provided tokens |
| _**refresh\_token**_ | string | a token used with **/v3/auth/exchange** to retrieve fresh tokens, without the re-executing the entire flow |
| _**scope**_ | array | granted permissions associated with the provided tokens |
| _**state**_ | string | general purpose string forwarded by the client in the first flow call |

### Call using POST method [POST]

+ Request (application/json)

    + Body

            {
                    "client_id": "bef41164-90c6-11e7-a25d-97266664a105",
                    "client_secret": "CLIENT_SECRET",
                    "response_type": "client_credentials",
                    "scope" : "application",
                    "state":"active"
            }

+ Response 200 (application/json)

        {
                "access_token":"pi34fshyb19niugymus2skd174nmp2z0j1nvmegaxz4ji0zfwjxolee74ydrv2x5s8zfly81hzh26v6295e0wxystsrb936l2xyr8w4t2grdxxo0pvz7l1lzz5298k5j",
                "client_id": "bef41164-90c6-11e7-a25d-97266664a105",
                "code":"2apu31cfkizrmneyt55hph5x2xadkp0rrqblvfhc7z47daalj29iw4bk28mpzg0r",
                "endpoints":{
                        "http":"https:\/\/api.platform.qa.muzzley.com",
                        "mqtt":"mqtts:\/\/api.platform.qa.muzzley.com:8883"
                },
                "expires":"2017-12-03T02:08:01.582+0000",
                "grant_type":"client_credentials",
                "refresh_token":"l8puku66syp5llktgrtrrxgw6vqc8hm109yfsf3wcm1t2dpkzoxs6na3na0zzc2q",
                "scope":[
                        "application"
                ]
        }

### Call using GET method [GET]

+ Parameters
    + client\_id (required, string)
    + client\_secret (required, string)
    + response\_type (required, string)
    + scope (required, string)
    + redirect\_uri (optional, string)
    + state (optional, string)

+ Request (application/json)

+ Response 307 

    + Headers 
      
            Location: https://mydomain.com/drop_credentials?expires=2017-12-03T02:08:01.582+0000&refresh_token=l8puku66syp5llktgrtrrxgw6vqc8hm109yfsf3wcm1t2dpkzoxs6na3na0zzc2q&access_token=pi34fshyb19niugymus2skd174nmp2z0j1nvmegaxz4ji0zfwjxolee74ydrv2x5s8zfly81hzh26v6295e0wxystsrb936l2xyr8w4t2grdxxo0pvz7l1lzz5298k5j

## Renew authorization [/v3/auth/exchange{?client\_id,refresh\_token,grant\_type,redirect\_uri}]

Before the expiration timestamp returned in _expires_, the _intervenient_ should renew the access token by calling **/v3/auth/exchange** endpoint, passing
the _refresh\_token_ return by the call to **/v3/auth/authorize**. 

The return will be exactly the same as return by **/v3/auth/authorize**.

### Request parameters

| PARAMETER | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**client\_id**_ | uuid | the client unique identifier, provided by the Muzzley self-care |
| _**redirect\_uri**_ | uri | URI to be provided to the user-agent as part of a **303** or **307** HTTP response |
| _**refresh\_token**_ | string | the token provided as _refresh\_token_ in a previous call to **/v3/auth/authorize** |
| _**grant\_type**_ | string | the type of grant flow used to generate the provided tokens |

### Response fields

| FIELD | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**access\_token**_ | string | the token to be used in subsequent calls to the API as part of an _HTTP Authorization_ header  |
| _**client\_id**_ | uuid | the client unique identifier |
| _**code**_ | string | an exchange code, for usage with _code_ flow requests |
| _**endpoints**_ | object | _HTTP_ and _MQTT_ base URLs assigned to the requesting client |
| _**expires**_ | timestamp | the expiration date for the provided tokens |
| _**grant\_type**_ | string | the type of grant flow used to generate the provided tokens |
| _**refresh\_token**_ | string | a token used with **/v3/auth/exchange** to retrieve fresh tokens, without executing the entire flow |
| _**scope**_ | array | granted permissions associated with the provided tokens |

### Call using POST method [POST]

+ Request (application/json)

    + Body

            {
                    "client_id": "bef41164-90c6-11e7-a25d-97266664a105",
                    "refresh_token": "l8puku66syp5llktgrtrrxgw6vqc8hm109yfsf3wcm1t2dpkzoxs6na3na0zzc2q",
                    "grant_type": "client_credentials"
            }

+ Response 200 (application/json)

        {
                "access_token": "7enfl95a36qa72go4cdgd7usvln0riijh19a1bmbtjdkkoltn5l5fcfth397snao5ut79gageyv41zfoiourpkt3a1b7p6bzr9jwwiqi26emu33qdabq1vufw627oetv",
                "client_id": "bef41164-90c6-11e7-a25d-97266664a105",
                "code": "cl98bv8kkvcu4ele2pnmsau2befvnuamni3eq6wu6oi4o410bwhn9sfalk9vds9q",
                "endpoints":{
                        "http":"https:\/\/api.platform.qa.muzzley.com",
                        "mqtt":"mqtts:\/\/api.platform.qa.muzzley.com:8883"
                },
                "expires":"2017-12-03T04:08:01.582+0000",
                "grant_type":"client_credentials",
                "refresh_token":"39cyl6fjcotgvkbc2cf3583r8xf2ezai37wknrijplenjb9ngt492ojww4zhffut",
                "scope":[
                        "application"
                ]
        }

### Call using GET method [GET]

+ Parameters
    + client\_id (required, string)
    + refresh\_token (required, string)
    + grant\_type (required, string)
    + redirect\_uri (optional, string)
    

+ Request (application/json)

+ Response 307 

    + Headers 
      
            Location: https://mydomain.com/drop_credentials?expires=2017-12-03T04:08:01.582+0000&refresh_token=39cyl6fjcotgvkbc2cf3583r8xf2ezai37wknrijplenjb9ngt492ojww4zhffut&access_token=7enfl95a36qa72go4cdgd7usvln0riijh19a1bmbtjdkkoltn5l5fcfth397snao5ut79gageyv41zfoiourpkt3a1b7p6bzr9jwwiqi26emu33qdabq1vufw627oetv


## Group Accessing channels with MQTT

For reading about the MQTT protocol, please, refer to the [official documentation](http://mqtt.org/)

Each _intervenient_ should listen for MQTT messages by subscribing it's channels topic. For instance:

if it's an application: /v3/applications/{application_id}/channels/#

Each _intervenient_ should send MQTT messages by publishing to the _channel_ topic, **/v3/channels/{channel_id}/components/{namespace}/properties/{namespace}/value**

Each _intervenient_ must provide is unique identifier (_client\_id_) as MQTT user and the previously retrieved _access\_token_ as password.

## Message structure

Each message received or sent to the MQTT topic associated with a given _property_ must state the underlying _performative_. The _performative_ contextualizes the 
receiving _intervenient_ on what to proceed. 

Allowed _performatives_ are:

- **w**, that asks the receiving _intervenient_ to change the _property_ value
- **r**, that ask the receiving _intervenient_ for the _property_ value
- **iw**, that informs the receiving _intervenient_ of the _property_ value, as a result of a **w** _performative_ message
- **ir**, that informs the receiving _intervenient_ of the _property_ value, as a result of a **r** _performative_ message

Every time the application receives a request to read or write and it is not possible to execute it due to a problem with an external API, a "iw" should be send back, to the property "access", with the following data: "unreachable".


### Message parameters

| PARAMETER | TYPE | DESCRIPTION |
|:------|:----:|:-------|
| _**io**_ | string | The _performative_, stating what to do with this message |
| _**value**_ | any | The _property_ value, structured as specified in the underlying _property spec_ |
| _**sender**_ | uuid | The requesting _intervenient_ unique identifier (read-only, no need to instantiate and if instantiate, overwritten by the platform) Same as the X-Client-Id from the webhook calls |
| _**on_behalf_of**_ | uuid | The _intervenient_ unique identifier on behalf of the requesting _intervenient_ is sending this message. Typically for _access tokens_ that were acquired through the **password** flow, that usually apply to the _application_ -> _user_ relation (read-only, no need to instantiate and if instantiate, overwritten by the platform) Same as the X-Owner-Id from the webhook calls |
| _**timestamp**_ | timestamp | Timestamp for the moment the message was sent (read-only, no need to instantiate and if instantiate, overwritten by the platform) |

### Example

```json
{
    "io" : "w",
    "sender" : "c9a78b2c-94a9-11e7-a76d-4b1c78a6ed17",
    "on_behalf_of" : "18f52e1a-9ebd-11e7-8613-e70c15c3f16f",
    "timestamp" : "2017-08-28T00:34::40.000+0000"
    "data" : {
        "location" : [ -34.9823479, 12.445989 ]
        "velocity" : 38.5587
    }
}
```

### MQTT clients

A list of MQTT clients support several developing languages:

- [Eclipse Paho](http://www.eclipse.org/paho/)
- [Mosquitto](https://mosquitto.org/)